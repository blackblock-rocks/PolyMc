{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PolyMc","text":"<p>PolyMc aims to be a compatibility layer between a modded server and the vanilla client. Allowing already existing mods to add blocks, items and other content without having to install the mod.</p> <p>The advantage of PolyMc is to separate the serverside mechanics from the hacks needed to display the mod on the client. PolyMc doesn't edit anything serverside, this means that mods adding blocks genuinely add those blocks, they'll have their own namespace and everything. It is only on the packet level that that block gets replaced with the block used for the client</p> <p>PolyMc is compatible with Fabric and Quilt and is licensed under the  LGPL. You can find the source code here.</p>"},{"location":"blockstates/","title":"Unused Block States","text":"<p>Warning</p> <p>This page was written around 1.18/1.19, and isn't up-to-date anymore</p> <p>Note</p> <p>This page is purely to document all unused block states in Minecraft,  which might be useful to explain PolyMc's behaviour or might help if you're doing some serverside hackery yourself.</p>"},{"location":"blockstates/#what-to-pay-attention-to","title":"What to pay attention to","text":"<ul> <li>Render layer</li> <li>Collision box</li> <li>Selection box</li> <li>Whether the state is waterlogged or not</li> </ul> <p>All of these blocks are unused on the client. This means that different states don't have different textures.  The properties are probably still used on the server. So it's important that you can still differentiate these on the server. (PolyMc does this by only working in the packet layer, none of the blocks inside the world are actually touched, they're just regular (modded) blocks).</p> <p>Note</p> <p>The number of blocks here usually represents the amount of states unless noted otherwise with a *.</p> <p>Warning</p> <p>This table has a bunch of information, I have no doubt made a mistake somewhere in here. If you notice any, or if there's an entry missing, please let me know.</p> Block # of blocks Used in PolyMc Renderlayer Notes Noteblocks 799 standard Note blocks only require a small bit of code to make sure the particles still work. All of their properties are only needed on the server, the client will still play the correct note even if it doesn't know the states. Needs resynchronizing when the block below changes. Beenest/Beehive 24 standard Beehives/nests only have a different texture for no honey and full honey. Target block 15 standard The block needs resynchronization when hit with an arrow. Dispenser/dropper 12 standard The client doesn't need to know whether the block is powered or not. Infested blocks 9 standard Infested blocks look the same as their un-infested counterparts. Copper blocks 4 standard Waxed copper blocks can be replaced with their unwaxed block states. Snowy mycelium/podzol 2 standard Snowy mycelium and podzol display the same as a snowy grass block Jukebox 1 standard There's a <code>has_record</code> property that the client doesn't need to care about. Tnt 1 <sup>3</sup> standard Tnt has an unstable property that the client doesn't need to care about. Note that tnt is instantly breakable, which might cause trouble if you're doing server-side block breaking. Double slabs 52 standard Double slabs have the same texture as their full block counterpart. The smooth stone double slab is the only exception to this. Waterlogged double slabs 53 standard These states are completely unused. Note that they will create water drip particles. Petrified oak slab 1* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper slab 4* standard Unlike the double slab states, this one can be used for actual slabs instead of just full blocks. Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of slabs you can make. Sculk sensors 60 cut-out Sculk sensors have a power propery that the client doesn't need to care about. Note that the \"active\" states produce particles and are emmisive. Sculk sensors have the same collisions as a lower half slab. Half of these states are waterlogged. Leaves 234 cut-out mipped Leaves have the advantage of not culling the blocks around them. All of their properties are not needed by the client. Half of these states are waterlogged, this isn't very noticeable though, as leaves are full blocks. They might produce particles Chorus Flower 4 cut-out Age 0 through 4 have the same texture. Chorus flower blocks have a full cube hitbox. Chorus Plant 17 cut-out The state without any connections and the states where both up and down are connected and any of the other sides of connected are impossible to achieve. They have weird hitboxes but they're mostly a full cube. Kelp 25 cut-out All of the states are waterlogged. Saplings 6 cut-out Saplings are blocks without collisions that have a large selection box. Their stage is only needed on the server. Sugarcane 15 cut-out Is coloured depending on the biome. Small dripleaf 6 cut-out The lower part of the dripleaf doesn't care about direction. Half of these are waterlogged. Tripwire 96 translucent (kinda) The client doesn't need to know if string is powered or detached. Needs resynchronizing if the block next to it changes and if that would change the string's state. Tripwire hooks 4 cut-out mipped The powered but not attached property is unused (TODO: confirm this). The block does have an unusual selection box. Cave vines 50 <sup>2</sup> cut-out The age isn't needed on the client. Note that this block is climbable. Twisting/weeping vines 50 cut-out These vines have an age property that the client doesn't need to care about. Note that the blocks are climbable. Plants ? <sup>5</sup> cut-out Certain plants (carrots, nether wart, etc) have certain age levels that don't have a separate texture. Buttons 32 standard Buttons facing north/south or east/west are the same when placed on the floor/ceiling. Fence gate 144 standard The client does not need to know whether the fence gate is powered or not. There are also some duplicate states for some directions. 64 of these states are open, making them usable as a block without collision. Doors 30* <sup>1</sup> cut-out The client does not need to know whether the door is powered or not. There are also some duplicate states, an open door to the north can be represented by a closed door to the west. Note that iron doors will behave differently. The \"# of blocks\" represents the amount of custom doors you can make here, as it doesn't make sense to list the amount of block states. Trapdoors 10* cut-out The client does not need to know whether the trapdoor is powered or not. Note that iron trapdoors will behave differently. The \"# of blocks\" represents the amount of custom trapdoors you can make here, as it doesn't make sense to list the amount of block states. Waxed copper stairs 4* standard Waxed copper blocks can be replaced with their unwaxed block states. The \"# of blocks\" represents the number of stairs you can make. Weighted pressure plates 28 standard There's a power level from 0-15, but there's only a texture for powered and unpowered. Farmland 6 standard Farmland has a collision box that makes it useful for paths, they're just lower than a full block. There's a moisture level from 0-7, but there's only a texture for unmoistured and moistured. Bamboo 1* <sup>5</sup> cut-out Bamboo has an age level that the client doesn't need to care about. This allows for 1 custom bamboo block. Cactus 15 cut-out Cacti have an age property that the client doesn't need to care about. They have an odd collision box though. Daylight detectors 30 <sup>5</sup> standard Daylight detectors have a powered property that the client doesn't need to care about. End portal frame 4 <sup>5</sup> standard End portal frames orientated north/south and east/west look the same. Scaffolding 28 <sup>5</sup> cut-out Scaffolding has a distance property that the client doesn't need to care about. Scaffolding does have weird movement properties and is climbable. Half of the states are waterlogged. Redstone 8 <sup>5</sup> cut-out Redstone has some unused states pointing in only one direction. Unfortunately power levels above 0 can't be used due to particles. They also have a weird selection box and are instantly breakable. Not a great block to work with. Hopper 1* <sup>5</sup> standard The client doesn't have to know whether the hopper is powered or not. This allows for 1 custom hopper. Bell 1* <sup>5</sup> standard The bell has a powered property that the client doesn't need to care about. This allows for 1 custom bell. Note that the bell itself is rendered with a ber. Lectern 1* <sup>5</sup> standard The lectern has a powered property that the client doesn't need to care about. This allows for 1 custom lectern. Stairs ? standard Stairs technically have some duplicate states, for example a stair facing north with a connection on the left is the same as a stair facing east with a connection on the right. They're not that useful. Walls 22* <sup>4</sup> standard Walls have a bunch of weird states, including one without selection box and collision box (like air). I'm sure they're useful for some specific cases but they're a very odd block. The \"# of blocks\" represents the amount of different wall variants. Beds 32 <sup>5</sup> cut-out Beds have an occupied property that the client doesn't care about. Note that beds are implemented using block entity renderers so you can only really add to the block. <ol> <li> <p>Only the powered state is currently implemented.\u00a0\u21a9</p> </li> <li> <p>Only cave vines without berries are used due to synchronization issues\u00a0\u21a9</p> </li> <li> <p>Currently disabled due to issues with tnt being instantly breakable.\u00a0\u21a9</p> </li> <li> <p>Only implemented for the air-like case. There are others, but they're a very odd shape. So it's not really worth it.\u00a0\u21a9</p> </li> <li> <p>Tracked in #145.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"config/","title":"Config","text":""},{"location":"config/#disabled-mixins","title":"Disabled mixins","text":"<p>This is a way to disable specific mixins within PolyMc. Doing this isn\u2019t recommended unless you know what the mixins do. Most mixins have an explanation in their javadoc.</p>"},{"location":"config/#misc","title":"misc","text":""},{"location":"config/#miscprocesssyncedblockeventserverside","title":"misc.processSyncedBlockEventServerSide","text":"<p>The server can send a block event packet to a client. This instructs the client to execute an event on that location. This is used for example with note blocks to make the sound and spawn the particle. This config has a list of blocks in the namespace:block format. The block event for those block will be executed on the server instead of the client. The results of this will vary per block. (The block event is specified in the Block#onSyncedBlockEvent)</p>"},{"location":"config/#remapvanillablockids","title":"remapVanillaBlockIds","text":"<p>This will ensure vanilla blocks keep the right ids. Switch this to true if a mod is messing up the ids, and you want it not to be messed up.</p>"},{"location":"config/#enablewizardthreading","title":"enableWizardThreading","text":"<p>Executes wizard updates on a different thread. This is experimental and will crash at this point in time. If you don't use add-on mods that add wizard you don't need to worry about this.</p>"},{"location":"config/#maxpacketspersecond","title":"maxPacketsPerSecond","text":"<p>Provides a rough estimate of the maximum amount of packets that should be sent per second. This isn't a hard limit.</p>"},{"location":"config/#forceblockidintcontrol","title":"forceBlockIdIntControl","text":"<p>Configures how PolyMc modifies some of the packets.  There's no real reason to set this to true unless you use polyvalent. Setting this to true may cause compatibility issues with other mods.</p>"},{"location":"config/#blockitemmatching","title":"blockItemMatching","text":"<p>Will poly block items to vanilla block items with the same placement behaviour and sound. For example, a modded ore might sound like stone, so it could get polyd with a vanilla stone block such as cobblestone or granite.</p> <p>When block item matching is disabled, the server has to reply to you right-clicking before the block appears on the client. With block item matching enabled, the client will immediately place the vanilla block for you, but the block won't look like a modded block until the server has replied. Thus, enabling this option is a tradeoff between latency/ping and aesthetics.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#does-this-work-with-bedrockgeysermc","title":"Does this work with Bedrock/GeyserMc?","text":"<p>tl;dr: no.</p> <p>The way bedrock works is quite different from Java. The hacks PolyMc does won't work well for Bedrock. I believe Geyser has a way to convert resource packs, so you might have some luck with that.  Ideally a separate mod would be created that handles Bedrock clients,  considering Bedrock actually supports custom blocks/items/entities, such a mod should work really well.  Unfortunately nobody actually has had the time to make it.</p>"},{"location":"faq/#why-is-this-block-stone","title":"Why is this block stone?","text":"<p>PolyMc might not be able to handle the collision shape of the block, or PolyMc might have run out of blocks.  See the limitations page.</p>"},{"location":"getting_started/","title":"Getting started with PolyMc","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>PolyMc is a normal mod and can be installed into the mods folder.</p> <p>Download latest version  View all versions </p>"},{"location":"getting_started/#generating-the-resource-pack","title":"Generating the resource pack","text":"<p>PolyMc requires a resource pack to be installed on the client to function<sup>1</sup>.  You can generate the resource pack by running the <code>/polymc generate resources</code> command.  It will appear in the root of your server in a folder named <code>resource</code>. How you distribute the resource pack is up to you.</p> <p>Warning</p> <p>Please check if you have the legal right to redistribute the assets of the mods you\u2019re using.</p>"},{"location":"getting_started/#need-help-info-or-support","title":"Need help, info or support?","text":"<p>Check the #PolyMc channel in the Fabric Serverside Development discord!</p> <p> </p> <ol> <li> <p>It\u2019s technically possible to use PolyMc without a resource pack,    but you'd have to use the api for that.\u00a0\u21a9</p> </li> </ol>"},{"location":"limitations/","title":"Limitations of PolyMc","text":"<p>Note</p> <p>PolyMc only affects what the client sees. The behaviour of things should always just work\u2122.</p> <p>PolyMc attempts to automatically convert blocks and items into things a vanilla client can understand. This may or may not actually work, depending on the mod. The only real way to know if a mod will work is to:</p> <p>Here's a list of what PolyMc can approximately do. </p> <p>Note</p> <p>These aren't guarantees, sometimes mods do wierd stuff.</p>"},{"location":"limitations/#items","title":"Items","text":"<p>All items should work perfectly fine.  You might encounter issues with items that use custom renders or edit their appearance with custom properties.</p>"},{"location":"limitations/#blocks","title":"Blocks","text":"<p>Your mileage will vary depending on the collision shape of the block.  It kinda has to match up with what the client thinks.</p> <p>PolyMc uses block states that go unused on the client side to display modded blocks. This means there's a limit to how many blocks can be added.  Here's an approximate, non-exhaustive, list of how many unused block states each collision shape has:</p> <ul> <li>Full blocks: 971</li> <li>Uncollidable blocks: 139 (can go up to 283)</li> <li>Doors: 9</li> <li>Trapdoors: 9</li> <li>Path blocks: 5</li> <li>Slabs: 5</li> <li>Stairs: 4</li> </ul>"},{"location":"limitations/#recipes","title":"Recipes","text":"<p>Recipes are fully functional. The data PolyMc sends to the recipe book will include the right nbt to display it properly. One caveat is that the recipe book's autofill doesn't care for nbt, so when filling in modded items it might get it wrong. PolyMc attempts to mitigate this by using as many different items as possible.</p>"},{"location":"limitations/#sounds","title":"Sounds","text":"<p>Custom sounds should totally work.</p>"},{"location":"limitations/#enchantments","title":"Enchantments","text":"<p>Custom enchantments should totally work.</p>"},{"location":"limitations/#guis","title":"Gui's","text":"<p>Kinda. By default, you'll just get a chest which contains the slots of the original gui. It's not pretty but it works. If your gui has buttons, or more slots than a chest, you're out of luck currently.  The system here can totally be made smarter, but I don't have the time.</p>"},{"location":"limitations/#entities","title":"Entities","text":"<p>PolyMc attempts to guess what entity looks kind of similar to the modded one. Often, this will be completely wrong. Unfortunately, there's not much else PolyMc can do here due to the way that entities are defined.  You can look at the api if you need to specify entities further.</p>"},{"location":"limitations/#breaking-speeds","title":"Breaking speeds","text":"<p>PolyMc automatically switches to calculating the breaking speed of custom blocks and items on the server when needed.  This means the client will receive mining fatigue and PolyMc will provide the breaking animation instead,  so custom tools and blocks will work fine with PolyMc.  Breaking modded stuff might be slightly more annoying with high ping but that hasn't been much of an issue so far.</p>"},{"location":"api/","title":"The PolyMc api","text":"<p>The PolyMc api allows you to use PolyMc's systems to edit the way PolyMc behaves. If a mod already works fine with PolyMc, you don't need to implement anything using the api.  But if certain things don't work, you might be able to use the api to fix those manually.  After all, not everything can be automated.</p> <p>There are also certain functions inside PolyMc that are only available via the api. Notably the wizard system.</p> <p>If you've got any questions about the api, don't hesitate to ask them in the #PolyMc channel of the Fabric Serverside Development discord.</p>"},{"location":"api/#importing-polymc","title":"Importing PolyMc","text":"<p>PolyMc's versioning scheme is <code>{polymc-version}+{mc-version}</code>. You can look here for a list of versions.</p> <pre><code>repositories {\n    maven {\n        url \"https://maven.theepicblock.nl\"\n        content { includeGroup(\"nl.theepicblock\") }\n    }\n}\n\ndependencies {\n   modImplementation \"nl.theepicblock:PolyMc:VERSION\"\n}\n</code></pre>"},{"location":"api/#entrypoint","title":"Entrypoint","text":"<p>PolyMc provides an entry point for you to interact with it. Implement <code>PolyMcEntrypoint</code> and add it to your <code>fabric.mod.json</code>: <pre><code>{\n  \"entrypoints\": {\n    \"polymc\": [\n      \"io.github.theepicblock.ExampleEntrypoint\"\n    ]\n  }\n}\n</code></pre></p>"},{"location":"api/blocks/","title":"Block polys","text":"<p>Block polys take in the servers sided blockstates and output one to be displayed on the client.  This can be any vanilla block you'd like. If your block kinda resembles a wool block,  you can make it look like a wool block. Usually you'd want to add some distinction to it though.</p> Wool block example <pre><code>public void registerPolys(PolyRegistry registry) {\n    registry.registerBlockPoly(customStone, new SimpleReplacementPoly(Blocks.WHITE_WOOL.getDefaultState()))\n}    \n</code></pre>"},{"location":"api/blocks/#wizards","title":"Wizards","text":"<p>You can attach a wizard to a block to summon entities or particles at it. See the section on wizards.</p>"},{"location":"api/blocks/#the-blockstatemanager","title":"The BlockStateManager","text":"<p>Minecraft has a limited amount of unused blockstates. Any block we want to be displayed on the client needs a blockstate.  The BlockStateManager has the job of tracking what blockstates are available for blocks to use.  Requests can be made to the BlockStateManager to get a blockstate of specific profile and then the BlockStateManager will  attempt to get an available blockstate for you.</p> <p>To get the BlockStateManager, use <code>PolyRegistry.getSharedValues(BlockStateManager.KEY)</code>.</p>"},{"location":"api/blocks/#block-profiles","title":"Block Profiles","text":"<p>TODO</p>"},{"location":"api/entities/","title":"Entities","text":"<p>Entity polys extend <code>EntityPoly</code>. This poly is basically just a factory for a <code>Wizard</code>. Wizards are explained in greater detail here,  they allow you to summon other vanilla entities to represent your modded one and can also do other things like sending particles. It's recommended to extend <code>EntityWizard</code> instead of <code>Wizard</code> to make your life easier.</p> <p>For an example, check out <code>MissingEntityPoly</code>, which is the default entity poly.  It simply spawns a barrier item to let people know that there's an entity there but PolyMc can't display it.</p>"},{"location":"api/guis/","title":"Guis","text":"<p>The PolyMc gui api allows you to replace any modded screenhandler with your own.  This allows you to do pretty much anything with the slots. Gui polys can be registered like any other poly using the <code>PolyRegistry#registerGuiPoly</code> function.</p> <pre><code>public class ExampleGuiPoly implements GuiPoly {\n    @Override\n    public ScreenHandler replaceScreenHandler(ScreenHandler base, ServerPlayerEntity player, int syncId) {\n        return new ExampleScreenHandler(ScreenHandlerType.GENERIC_9X3, syncId, player.getInventory(), base);\n    }\n\n    public static class ExampleScreenHandler extends ScreenHandler {\n        protected final ScreenHandler base;\n\n        protected ExampleScreenHandler(ScreenHandlerType&lt;?&gt; type, int syncId, PlayerInventory playerInventory, ScreenHandler base) {\n            this.base = base;\n            for (int y = 0; y &lt; 9; ++y) {\n                for (int x = 0; x &lt; 3; ++x) {\n                    this.addSlot(new StaticSlot(new ItemStack(Items.BLACK_STAINED_GLASS_PANE)));\n                }\n            }\n\n            //Player inventory\n            for (int y = 0; y &lt; 3; ++y) {\n                for (int x = 0; x &lt; 9; ++x) {\n                    this.addSlot(new Slot(playerInventory, x + y * 9 + 9, 8 + x * 18, 84 + y * 18));\n                }\n            }\n\n            //Player hotbar\n            for (int hotbar = 0; hotbar &lt; 9; ++hotbar) {\n                this.addSlot(new Slot(playerInventory, hotbar, 8 + hotbar * 18, 142));\n            }\n        }\n\n        @Override\n        public ItemStack transferSlot(PlayerEntity player, int index) {\n            // For this example, you've got to make sure the indexes align with those from the base screenhandler. This depends on what screenhandler is your base.\n            base.transferSlot(player, index-x);\n        }\n    }\n}\n</code></pre>"},{"location":"api/guis/#using-sgui-recommended","title":"Using SGui (recommended)","text":"<p>It quickly gets tedious to write your own screenhandlers.  SGui is a small library that's much better for making serverside gui's.  You can use SGui in a GuiPoly by opening your gui via SGui like normal and then returning <code>null</code> to prevent PolyMc from opening any other screenhandlers. <pre><code>public class SGuiExample implements GuiPoly {\n    @Override\n    public ScreenHandler replaceScreenHandler(ScreenHandler base, ServerPlayerEntity player, int syncId) {\n        var gui = new SimpleGui(ScreenHandlerType.GENERIC_3X3, player, false);\n        gui.setTitle(Text.literal(\"SGui test\"));\n        gui.open();\n        return null;\n    }\n}\n</code></pre></p>"},{"location":"api/items/","title":"Item polys","text":"<p>The default poly generation for items works really well, so I don't know why you'd want to  make a custom item poly. But I'm not here to judge. </p> <p>One basic thing you might want to do is to use a different base item for your modded item. This is easy enough: <pre><code>public void registerPolys(PolyRegistry registry) {\n    registry.registerItemPoly(moddedItem, new CustomModelDataPoly(registery.getCMDManager(), moddedItem, Items.DIAMOND_SWORD))\n}\n</code></pre></p> <p>Note</p> <p>If your item is damageable, use <code>DamageableItemPoly</code> instead of <code>CustomModelDataPoly</code>.</p> <p>If you want to create your own item poly, you should implement the <code>ItemPoly</code> interface.  Never modify the input itemstack directly, always make a copy before doing so.</p>"},{"location":"api/items/#global-item-polys","title":"Global item polys","text":"<p>Global item polys are applied to all items before they are sent to the client.  Global item polys implement ItemTransformer and can be registered using PolyRegistry#registerGlobalItemPoly.  Keep in mind that, like normal item polys, global item polys should never modify the input itemstack directly.</p>"},{"location":"api/items/#the-custommodeldatamanager","title":"The CustomModelDataManager","text":"<p>The CMD manager is made to prevent polys from using the same CMD values on the same items.  At the simplest level, you can request a CMD value to use for a specific item.  You can also request a number of values, the number returned is the first value you may use, see the javadoc for more detail.  The CMD manager can also round-robin from a list of items.  This is the preferred way of doing things as this prevents recipe conflicts  (the recipe book doesn\u2019t take the CMD value into account, this isn\u2019t a huge deal but is a minor annoyance to clients).</p> <p>To get the CustomModelDataManager, use <code>PolyRegistry.getSharedValues(CustomModelDataManager.KEY)</code>.</p>"},{"location":"api/misc/","title":"Misc","text":""},{"location":"api/misc/#shared-values","title":"Shared Values","text":"<p>The PolyRegistry keeps track of certain shared values. For example, the <code>CustomModelDataManager</code>.  Shared values allow you to allocate things like CMD values, blockstates, or specific colours of armor.  You could also use shared values to, for example, generate a models for every block in the game,  and then you can reuse these models across your polys.</p> <p>It's rare for you to want to create your own shared value, but if you do want to do it, you'll need to create a <code>SharedValuesKey</code>. This key contains a builder for your class, which will contain all the data you want to store, and a resource factory.  That last one requires a bit more explanation, in general shared values are stored only in the <code>PolyRegistry</code>  and are thrown away once the registration phase is done. (You should never keep a reference to a shared value). But you might want to use your data to generate resources. In that case you do want to keep the information needed  to generate those resources.  The resource factory should take in your shared values and return a class which only contains the information  needed for resource generation. If you don't need resource generation, simply use <code>null</code>, you can also take a look at <code>ArmorColorManager</code> for an example. For <code>ArmorColorManager</code> all of the info is still needed during resource gen so the resource factory simply returns itself.</p>"},{"location":"api/polymaps/","title":"PolyMaps","text":"<p>The PolyMap is what stores all the polys that PolyMc uses. These Polys in turn define how different things are transformed. By default, PolyMc will generate a single PolyMap using the <code>PolyRegistry</code>. This acts as a builder for the PolyMap. You can add stuff to the <code>PolyRegistry</code> via the <code>registerPolys</code> method in your entrypoint.</p> <p>After the entrypoint is called, PolyMc will iterate the registries and attempt to auto generate polys for anything that doesn't have them.</p>"},{"location":"api/polymaps/#custom-polymaps","title":"Custom PolyMaps","text":"<p>You can actually assign different PolyMaps to different players. The PolyMap used for a player is determined by the  <code>PolyMapProvider.EVENT</code> event.</p> <p>example<pre><code>PolyMapProvider.EVENT.register(player -&gt; {\n        if (isSpecial(player)) {\n            return MY_SPECIAL_POLYMAP;\n        } else {\n            return null;\n        }\n});\n</code></pre> Using this feature you can also completely disable PolyMc for a player. This is done by returning a <code>NOPPolyMap</code>. Other uses for this include, for example, a PolyMap that doesn't use a resource pack. Simply instantiate a new <code>PolyRegistry</code>, somehow make sure none of the polys use resource packs,  build the PolyMap from the registry, and then you're good to go.</p>"},{"location":"api/resources/","title":"Resources","text":"<p>You can append resources when a resource pack is generated in multiple places.  Most common is the <code>addToResourcePack</code> function inside a poly.  There's also a <code>registerModSpecificResources</code> inside your entrypoint,  but it's recommended to use shared values instead.</p> <p>In all of these cases, you'll get two classes; <code>ModdedResources</code> and a <code>PolyMcResourcePack</code>.</p> <p><code>ModdedResources</code> gives you access to the modded files. You can query for a variety of things.  It also allows you to access the client jar, giving you access to Minecraft's own assets.  Be very careful with copyright issues.</p> <p><code>PolyMcResourcePack</code> represents the resource pack that's being generated.  You can retrieve files, edit them, and add new files.</p>"},{"location":"api/resources/#retrieving-vanilla-assets","title":"Retrieving vanilla assets","text":"<p>Warning</p> <p>Please use vanilla assets sparingly!  PolyMc only copies over very basic stuff that isn't really copyrightable, such as <code>item/generated</code> type item models. The only texture PolyMc copies over is the leather armour texture, which is because all armours need to be inside one file for FancyPants. I highly doubt Mojang is going to take any legal action, after all we're doing some pretty cool stuff, but it might be best to play it safe and give people a heads-up if the resource pack is going to include a bunch of Mojang textures.</p> <p>PolyMc automatically downloads the client jar, so it can access its assets.  You can access these assets via the api using the <code>getClientJar</code> and <code>includeClientJar</code> methods inside <code>ModdedResources</code>. The first one will return only assets inside the client jar whilst the latter will include both vanilla assets and other modded assets.</p>"},{"location":"api/wizards/","title":"Wizards","text":"<p>At an abstract level, wizards are objects that exist in a location in the world and can send  packets to players in watching distance. (Ignore the name, I was going to name them block entities, but that's already taken. So we're calling them wizards) You're probably just going to use wizards to spawn armor stands. But technically you could also spawn particles or other entities.</p> <p>Wizards can be attached to both entities and blocks.  For example, you could have an aquarium block that spawns a fish when it's placed.  Or you could make summon a zombie to represent your modded entity.</p>"},{"location":"api/wizards/#basics","title":"Basics","text":"<p>Wizards have 3 main methods you can override. <code>addPlayer</code>, <code>removePlayer</code> and <code>onMove</code>. <code>addPlayer</code> and <code>removePlayer</code> are called when a player enters/exits the watch distance. If you're spawning entities, you should use <code>addPlayer</code> to send a summon packet and <code>removePlayer</code> to send a remove packet. Use <code>onMove</code> will be called every tick for entities, and when a block is moved (for example with a piston). Use this method to move your entity.</p>"},{"location":"api/wizards/#blocks","title":"Blocks","text":""},{"location":"api/wizards/#adding","title":"Adding","text":"<p>Wizards can be added to blocks via the block's block poly. <pre><code>@Override\npublic boolean hasWizard() {\n    return true;\n}\n\n@Override\npublic Wizard createWizard(ServerWorld world, Vec3d pos, WizardState state) {\n    return new MyWizard(world, pos, state);\n}\n</code></pre></p> <p>Note</p> <p>PolyMc automatically handles cases such as when your block is pushed by a piston or if your block is placed inside a falling sand entity. This is why you should implement <code>onMove</code> even for blocks.</p>"},{"location":"api/wizards/#entities","title":"Entities","text":"<p>Attaching a wizard to an entity is similar to attaching one to attaching one to a block.  It's recommended to implement <code>EntityWizard</code> instead of <code>Wizard</code> so you have access to the entity.  See also: entities.</p>"},{"location":"api/wizards/#ticking","title":"Ticking","text":"<p>The <code>onTick</code> function isn't called by default. You'll have to override <code>needsTicking</code> as well. </p> Ticking Example <p>This example spawns a particle in the center of a block every tick. <pre><code>public class MyTickingWizard extends Wizard {\n    @Override\n    public void onTick() {\n        this.getPlayersWatchingChunk().forEach(player -&gt; {\n                player.networkHandler.sendPacket(new ParticleS2CPacket(ParticleTypes.WAX_ON,\n                false,\n                this.getPosition().x,\n                this.getPosition().y+0.5,\n                this.getPosition().z,\n                0, 0, 0, 0, 0));\n        });\n    }\n\n    @Override\n    public boolean needsTicking() {\n        return true;\n    }\n}\n</code></pre></p> <p>Note</p> <p>The way ticking works will likely be changed in the future to allow for packets to be sent faster than 20hz.</p>"},{"location":"api/wizards/#virtual-entity-api","title":"Virtual Entity API","text":"<p>The virtual entity api is an api to easily send packets as if they come from an actual entity. This gives full control over the packets sent and removes the need to construct an <code>Entity</code> object.</p>"},{"location":"api/wizards/#example","title":"Example","text":"<pre><code>public class MyWizard extends Wizard {\n    private final VItemFrame virtualItemFrame = new VItemFrame();\n\n    @Override\n    public void addPlayer(ServerPlayerEntity playerEntity) {\n        virtualItemFrame.spawn(playerEntity, this.getPosition(), Direction.DOWN);\n        virtualItemFrame.sendItemStack(playerEntity, new ItemStack(Items.STICK));\n        virtualItemFrame.makeInvisible(playerEntity);\n    }\n\n    @Override\n    public void removePlayer(ServerPlayerEntity playerEntity) {\n        virtualItemFrame.remove(playerEntity);\n    }\n\n    @Override\n    public void onMove() {\n        this.getPlayersWatchingChunk().forEach((player) -&gt; virtualItemFrame.move(player, this.getPosition(), (byte)0, (byte)0, true));\n    }\n}\n</code></pre>"}]}